//开始是按数从1到N计算的，复杂度10^12，而且算到a_17就得5mins，改成计算数字和，算到10^15只用了0.002s
// #Wed, 07 Mar 2012 23:07:21 +0800
// 
// 加了个额外的限制条件N，但是得到30个结果后停止不一定能保证第三十个数就在里
// 面，因为这样算出的结果是无序的。所以这样得出结果应该有些侥幸。看了Thread里
// 的答案，也有限定底数和指数范围，然后求解的，感觉也不太严谨。
// #14/10/09/19:42:24/Thursday
#include <stdio.h>
#include <string.h>
#include <algorithm>

const int n=30;
long long a[n+1];
long long N=1000000000000000;

int digs(long long n)
{
	int res=0;
	while(n)
	{
		res+=n%10;
		n/=10;
	}
	return res;
}
int main()
{
	long long t;
	int f=1;
	for(int i=2;f<=n;++i)
	{
		t=i;
		while(t<N)
		{
			if(digs(t)==i)
			{
				if(t>10)
				{
					a[f]=t;
					printf("%d:%lld\tdigsum is %d\n",f,t,i);
					++f;
				}
			}
			t*=i;
		}
	}
	std::sort(a+1,a+f);
	printf("a[30]: %lld\n",a[n]);
	return 0;
}


//81
//512
//2401
//4913
//5832
//17576
//19683
//234256
//390625
//614656
//1679616
//17210368
//34012224
//52521875
//60466176
//205962976
//612220032
//8303765625
//10460353203
//24794911296
//27512614111
//52523350144
//68719476736
//271818611107
//1174711139837
//2207984167552
//6722988818432
//20047612231936
//72301961339136
//248155780267521
