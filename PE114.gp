/********************************
 * Author:			bigeast
 * Time:			2014-10-12
 * Description:		AC!! answer is 16475640049. 6023rd.
 记忆中这个题困扰了好久了！！

 今天终于把公式推出来了。开始想到用动态规划，把n长的木板用空档分成两个部分，然
 后两部分的答案综合，求和，跟Catlan的过程相似。但是后来发现有问题。
 然后考虑用两个状态的DP，f[i][j]代表把长为i的木板分成j部分的方法数。推导状态转
 移方程的过程中发现，其实可以不用DP，直接就能算出答案。

 最短填充长度为m，就先把n分成若干个长为m的段，然后用空档分开，例如n=k*m+k-1表
 示把n分成k个长为m的段，中间用空档隔开（n可能有剩余）。这样解出要分的段数
 k=floor((n+1)/(m+1))，然后把剩下的n-(k*m+k-1)个球，放入2*k+1个位置中，这2*k+1个位置
 包括了填充的k段长为m的板所在的位置，和间隔这k个填充段的k-1个空档，还有两边的
 两个空档！方法数为binomial(n-k*m-k+1+2*k+1-1,2*k+1-1)=binomial(n-k*m+k+1,2*k)
 将k从0到floor((n+1)/(m+1))的答案相加就是最终答案！
 ********************************/

n = 50;
m = 3;
ans = 0;
for(X=0,(n+1)/(m+1),ans+=binomial(n-(m-1)*X+1,2*X));
print(ans)
