* PE40

> **Champernowne's constant**
> 将连续的自然数写到字符串中，求任意位置的字符。《编程之美》上好像也有。

* [ ] PE156

> 同样是 **Champernowne's constant** 相关的问题。用f(n,d)表示前n个数字中d出现的次数，求f(n,d) = n的所有解。

* PE53

> double类型的能力：计算 n choose k

* PE61

> 还用到了dfs，有点意思。好像当时也是花了很大功夫的。

* PE75

> 整数边的直角三角形。解Pell方程能得到一个公式吧。
	a=m^2-n^2,b=m^2+n^2,c=2*m*n

* PE76, PE77

> 整数分划，素数分划。用动态规划求解。

* PE122

> 加法链问题，NP。求a^n的最少的乘法次数。快速幂的结果不一定最优。

* PE282

> **Ackermann Function** 求A(4,4),A(5,5),A(6,6)

* [x] PE287

> Quadtree encoding

* PE375

> 查询区间内的最小值。线段树？
> 可能是统计每个数最终被计算的次数？例如比相邻的两个数都大的数，只会被计算一次。
> 记a[i]向左和向右第一个小于等于a[i]的数的下标是L[i]和R[i]，那么a[i]在最终的求和中会被加(i - R[i]) * (L[i] - i)次。

* [x] PE179

> 1~10^7的所有数的约数个数。可以在O(nlog(n))时间复杂度内解决！
> 方法就是类似筛法，i从1到n，然后把所有numdiv[k*i]都加一。

* [x] PE336

> 11!次枚举，模拟。应该不难！
> Solved. 果然是暴力。不过Thread中有人用动态规划的，膜拜。

* PE483

> 置换群中元素的阶数。

* [x] PE479

> ~~公式推出了一半，根与系数的关系展开，最后得到![equation](data/PE479.png)， 然后算不动了。继续努力。~~ 
> 到这一步已经是最后了，剩下的就需要算了，用快速幂取模和扩展欧几里德。（第一次
> 竟然没想到，估计连推导带实现总共花费了超过四个小时。）

* [x] PE216

> 当时用的是暴力，重新看下吧，官网上有pdf版本的解答！

* [ ] PE437

> 小于10^8的素数的Fibonacci原根。
> 即在模n的整数域中，任何元素都可以写成原根p的整数次幂。幂次就是元素的离散对数。
> 不是只有素数才有原根。原根通常不唯一。
> PrimePi[10^8] = 5761455，暴力求解N的所有原根的复杂度是N。

* [x] PE351

> 欧拉Phi函数的应用。

* [ ] PE252

> 平面上500个随机点，求其中不包含其余点的面积最大的凸包的面积。

* [x] PE199

> 大圆被相等的三个小圆填充，然后剩下的区域不断被新的圆填充，迭代十次后，大圆中未被小圆覆盖的面积。
> 记得是自己想出来的dfs方法。然而代码没有注释现在看不懂了。

* [x] PE170

> 0-9中选一个数字，然后剩下的数字分成两部分，组成两个数字分别与选出的数字相乘，得到的两个乘积，刚好也是0-9组成。
> 这题跟PE199难度都是70%，是我做出的题目中最难的两个了。

* [ ] PE377

> 有序整数分划[Composition](https://en.wikipedia.org/wiki/Composition_(combinatorics)
> 13^i 的所有有序整数分划组成的数字相加，求最后的9位数字。这个9很关键。当13^2时，所有的分划方式都已经超过了9位。13要单独拿出来处理。
> 有序分划的个数是有公式的，即2^(n-1)，但要生成所有的分划，还是需要搜索。
> 基本思路是，固定后9位数字之和N（9到81），然后DFS搜索得到每一种分划，以该分划S结尾的分划个数，是13^i-N的有序分划数，即2^(13^i-N)，用快速幂取模的算法计算其后9位，然后与得到的S相乘（会超过long long，需要特殊处理）。
> 9到81两头搜索起来很快，但中间，50左右，每计算一个就需要花费将近两分钟!
